package main

import (
	"fmt"
	"log"
	"sort"
	"strings"
)

type GeneratorGolang struct {
	stdTypes map[string]StdTypeDef
}

func NewGeneratorGolang() *GeneratorGolang {
	return &GeneratorGolang{stdTypes: stdTypesGo}
}

// 是否基础类型
func (gen *GeneratorGolang) isStdType(t string) bool {
	for k, _ := range gen.stdTypes {
		if k == t {
			return true
		}
	}
	return false
}

func (gen *GeneratorGolang) anyType() string {
	return "interface{}"
}

func (gen *GeneratorGolang) GetGenFilePath() string {
	return *outputDir + currProtoConfig.process.GetNamespace() + "_init.go"
}
func (gen *GeneratorGolang) GenHeader(p ProtoProcess) string {
	start := int(*startId)
	initText := ""
	tables := p.GetTables()
	if *sortMsg > 0 {
		sort.Slice(tables, func(i, j int) bool { return tables[i] < tables[j] })
	}
	for i, v := range tables {
		id := currGenIDFunc(start, i, v)
		initText += fmt.Sprintf("	addProtoDef(%v,&%s{})\n", id, v)
	}

	tabExtText := ""
	for i, v := range tables {
		id := currGenIDFunc(start, i, v)
		tabExtText += fmt.Sprintf(tabExtTemplate, v, id, v, v, v, id)
	}

	importText := ""
	confs := p.GenExternConf()
	var imports []string
	if confs != nil {
		imports = getImportgo(confs)

	}

	if len(*importpack) > 0 {
		argsImports := strings.Split(*importpack, ",")
		imports = append(imports, argsImports...)
	}

	if len(imports) > 0 {
		for _, s := range imports {
			importText += fmt.Sprintf("import . \"%s\"\n", s)
		}
	}

	vs := strings.Split(*version, "#")
	vstring := fmt.Sprintf("const %s = \"%s\"\n", vs[0], vs[1])
	content := fmt.Sprintf(fileTemplate, p.GetNamespace(), vstring, importText, initText, tabExtText)
	content += gen.genNewType(p)
	return content
}

func (gen *GeneratorGolang) GenExtern(p ProtoProcess) string {
	confs := p.GenExternConf()
	if confs == nil {
		return ""
	}

	content := ""
	for _, conf := range confs {
		for _, v := range conf.Messages {
			content += gen.genMsg(&v)
		}
	}
	return content
}

func (gen *GeneratorGolang) genNewType(p ProtoProcess) string {
	msgName := p.GetNamespace()
	if len(*mgrname) > 0 {
		msgName = *mgrname
	}

	start := int(*startId)
	caseContent := ""
	for i, msg := range p.GetTables() {
		id := currGenIDFunc(start, i, msg)
		caseContent += fmt.Sprintf(`
	case %v:
		return &%s{}, true
		`, id, msg)
	}
	content := fmt.Sprintf(newTypeTemplate, msgName, currProtoConfig.newTypeMsgGo, caseContent)
	return content
}

const newTypeTemplate = `
func New%s(id MsgIDType) (%s, bool) {
	switch id {
%s		
	}

	return nil, false
}
`

// 总文件模板
var fileTemplate = `// Code generated by the proto_gen_ext. DO NOT EDIT.
package %s

%s
%s

func init()  {
%s
}

%s
`

// 注入函数模板
var tabExtTemplate = `
// GetID 
func (tab *%s) GetMsgID() MsgIDType {
	return %v
}

// GetMsgName
func (tab *%s) GetMsgName() string {
	return "%v"
}

func Get%sMsgID() MsgIDType {
	return %v
}

`

const structTemplate = `
// %s
type %s struct {
%s
}
`

const funcTemplatye = `
func (tab *%s) Write(s IStream) error {
%s
	return nil
}

func (tab *%s) Read(s IStream) error {
%s
	return nil
}

func (tab *%s) GetStreamSize() int {
	var size int = 0
%s
	return size
}
`

func (gen *GeneratorGolang) genMsg(msg *MsgDef) string {
	content := ""
	content += gen.genStruct(msg)
	content += gen.genFunc(msg)

	return content
}
func (gen *GeneratorGolang) genStruct(msg *MsgDef) string {

	fieldContent := ""
	for _, f := range msg.Fields {
		tname := f.Type
		if gen.isStdType(f.Type) {
			tname = gen.stdTypes[f.Type].TypeName
		} else if isAnyType(f.Type) {
			tname = gen.anyType()
		}
		fieldContent += fmt.Sprintf("	%s %s\n", f.Name, tname)
	}
	content := fmt.Sprintf(structTemplate, msg.About, msg.Name, fieldContent)
	return content
}

// fname,read,fname
const readArrayStdTemplate = `
	tab.%s = nil
	if l,err:= s.ReadUint16(); err!=nil {
		return err
	} else {
		for i := 0; i < int(l); i++ {
			v, err := s.%s()
			if err != nil {
				return err
			}
			tab.%s = append(tab.%s, v)
		}
	}
`

// fname,ftype,fname,fname
const readArrayStructTemplate = `
	tab.%s = nil
	if l,err:= s.ReadUint16(); err!=nil {
		return err
	} else {
		for i := 0; i < int(l); i++ {
			v := %s{}
			err := v.Read(s)
			if err != nil {
				return err
			}
			tab.%s = append(tab.%s, v)
		}
	}
`

const writeArrayStdTemplate = `
	s.WriteUint16(uint16(len(tab.%s)))
	for _, v := range tab.%s {
		s.%s(v)
	}
`
const writeArrayStructTemplate = `
	s.WriteUint16(uint16(len(tab.%s)))
	for _, v := range tab.%s {
		v.Write(s)
	}
`

const readStdTemplate = `
	if v, err := s.%s(); err != nil {
		return err
	} else {
		tab.%s = v
	}
`
const readAnyTemplate = `
	if v, err := unPackAny(s); err == nil {
		tab.%s = v
	} else {
		return err
	}
`
const readStructTemplate = `
	tab.%s = %s{}
	err := tab.%s.Read(s)
	if err!=nil {
		return err
	}
`
const getStreamSizeArrayStructTemplate = `
	for _, v := range tab.%s {
		size += v.GetStreamSize()
	}
`
const getStreamSizeStringListTemplate = `
	for _, v := range tab.%s {
		size += 2
		size += len(v)
	}
`
const getStreamSizeAnyTemplate = `
	if sz,b := getSizeAny(tab.%s);b {
		size += sz
	}
`

func (gen *GeneratorGolang) genFunc(msg *MsgDef) string {
	writeContent := ""
	for _, f := range msg.Fields {
		if gen.isStdType(f.Type) { //isStdType
			writeContent += fmt.Sprintf("	s.%s(tab.%s)\n", gen.stdTypes[f.Type].Write, f.Name)
		} else if b, etype := isArrayType(f.Type); b { //isArrayType
			if etype == "bytes" {
				log.Fatal("not support []bytes")
			}
			if gen.isStdType(etype) {
				writeContent += fmt.Sprintf(writeArrayStdTemplate, f.Name, f.Name, gen.stdTypes[etype].Write)
			} else { //struct
				writeContent += fmt.Sprintf(writeArrayStructTemplate, f.Name, f.Name)
			}
		} else if isAnyType(f.Type) {
			writeContent += fmt.Sprintf("	packAny(tab.%s,s)\n", f.Name)
		} else {
			writeContent += fmt.Sprintf("	tab.%s.Write(s)\n", f.Name)
		}
	}

	readContent := ""
	for _, f := range msg.Fields {
		if gen.isStdType(f.Type) { //isStdType
			readContent += fmt.Sprintf(readStdTemplate, gen.stdTypes[f.Type].Read, f.Name)
		} else if b, etype := isArrayType(f.Type); b { //isArrayType
			if gen.isStdType(etype) {
				readContent += fmt.Sprintf(readArrayStdTemplate, f.Name, gen.stdTypes[etype].Read, f.Name, f.Name)
			} else {
				readContent += fmt.Sprintf(readArrayStructTemplate, f.Name, etype, f.Name, f.Name)
			}
		} else if isAnyType(f.Type) {
			readContent += fmt.Sprintf(readAnyTemplate, f.Name)
		} else { //struct
			readContent += fmt.Sprintf(readStructTemplate, f.Name, f.Type, f.Name)
		}
	}

	sizeContent := ""
	for _, f := range msg.Fields {
		if gen.isStdType(f.Type) {
			sizeContent += fmt.Sprintf("	size += %v\n", gen.stdTypes[f.Type].Size)
			if gen.stdTypes[f.Type].ElemSize > 0 {
				sizeContent += fmt.Sprintf("	size += len(tab.%s)*%v\n", f.Name, gen.stdTypes[f.Type].ElemSize)
			}

		} else if b, etype := isArrayType(f.Type); b { //isArrayType
			sizeContent += "	size += 2\n"
			if etype == "string" {
				sizeContent += fmt.Sprintf(getStreamSizeStringListTemplate, f.Name)
			} else if gen.isStdType(etype) {
				sizeContent += fmt.Sprintf("	size += len(tab.%s) * %v\n", f.Name, gen.stdTypes[etype].Size)
			} else {
				sizeContent += fmt.Sprintf(getStreamSizeArrayStructTemplate, f.Name)
			}
		} else if isAnyType(f.Type) {
			sizeContent += fmt.Sprintf(getStreamSizeAnyTemplate, f.Name)
		} else {
			sizeContent += fmt.Sprintf("	size += tab.%s.GetStreamSize()\n", f.Name)
		}
	}

	content := fmt.Sprintf(funcTemplatye, msg.Name, writeContent, msg.Name, readContent, msg.Name, sizeContent)
	return content
}
